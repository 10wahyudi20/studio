
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview A general-purpose personal AI assistant with farm data analysis capabilities.
 *
 * - personalAssistant - Handles conversational AI interactions.
 * - PersonalAssistantInput - The input type for the personalAssistant function.
 * - PersonalAssistantOutput - The return type for the personalAssistant function.
 * - Message - The type for a single message in the conversation history.
 */

import {ai} from '@/ai/genkit';
import {Part, Role} from 'genkit/model';
import {z} from 'genkit';
import { format } from "date-fns";
import { id as idLocale } from "date-fns/locale";
import { Duck, EggProduction, Feed, Transaction } from '@/lib/types';


// Define Zod schemas for the application data types to be used in tools
const DuckSchema = z.object({
  cage: z.number(),
  quantity: z.number(),
  deaths: z.number(),
  entryDate: z.string(), // Use string for simplicity in AI context
  ageMonths: z.number(),
  status: z.enum(['Bebek Bayah', 'Bebek Petelur', 'Bebek Tua', 'Bebek Afkir']),
  cageSize: z.string(),
  cageSystem: z.enum(['baterai', 'umbaran']),
});
const EggProductionSchema = z.any(); // Using z.any() for complex nested objects for now
const FeedSchema = z.any();
const TransactionSchema = z.any();


// Define the structure for a single message in the history
const MessageSchema = z.object({
  role: z.enum(['user', 'model']),
  content: z.string(),
  imageUrl: z.string().optional().describe("A URL of an image associated with the message, if any. Can be a data URI."),
});
export type Message = z.infer<typeof MessageSchema>;


const PersonalAssistantInputSchema = z.object({
  history: z.array(MessageSchema).describe('The conversation history.'),
  prompt: z.string().describe('The user\'s latest prompt.'),
  imageDataUri: z.string().optional().describe(
    "An optional image provided by the user, as a data URI."
  ),
  // Add farm data to the input
  ducks: z.array(DuckSchema).optional().describe("Current duck inventory data."),
  eggProduction: EggProductionSchema.optional().describe("Egg production data."),
  feed: z.array(FeedSchema).optional().describe("Feed inventory data."),
  finance: z.array(TransactionSchema).optional().describe("Financial transaction data."),
});
export type PersonalAssistantInput = z.infer<typeof PersonalAssistantInputSchema>;

const PersonalAssistantOutputSchema = z.object({
  response: z.string().describe('The AI\'s response.'),
});
export type PersonalAssistantOutput = z.infer<typeof PersonalAssistantOutputSchema>;

// Define Tools for the AI
const getDuckPopulationData = ai.defineTool(
    {
        name: 'getDuckPopulationData',
        description: 'Get data about the current duck population and inventory.',
        inputSchema: z.void(),
        outputSchema: z.array(DuckSchema),
    },
    async (_, flow) => {
        return flow.state.ducks || [];
    }
);

const getEggProductionData = ai.defineTool(
    {
        name: 'getEggProductionData',
        description: 'Get data about daily, weekly, and monthly egg production.',
        inputSchema: z.void(),
        outputSchema: EggProductionSchema,
    },
    async (_, flow) => {
        return flow.state.eggProduction || { daily: [], weekly: [], monthly: [] };
    }
);

const getFeedData = ai.defineTool(
    {
        name: 'getFeedData',
        description: 'Get data about feed inventory, suppliers, and prices.',
        inputSchema: z.void(),
        outputSchema: z.array(FeedSchema),
    },
    async (_, flow) => {
        return flow.state.feed || [];
    }
);

const getFinancialData = ai.defineTool(
    {
        name: 'getFinancialData',
        description: 'Get financial data, including income (debit) and expenses (credit).',
        inputSchema: z.void(),
        outputSchema: z.array(TransactionSchema),
    },
    async (_, flow) => {
        return flow.state.finance || [];
    }
);


export async function personalAssistant(input: PersonalAssistantInput): Promise<PersonalAssistantOutput> {
  return personalAssistantFlow(input);
}

const personalAssistantFlow = ai.defineFlow(
  {
    name: 'personalAssistantFlow',
    inputSchema: PersonalAssistantInputSchema,
    outputSchema: PersonalAssistantOutputSchema,
  },
  async (input) => {
    
    // Store farm data in the flow's state to make it accessible to tools
    ai.setState(input);

    // Format previous messages for the model
    const formattedHistory: {role: Role; content: Part[]}[] = input.history.map(msg => ({
      role: msg.role as Role,
      content: [
          ...(msg.imageUrl ? [{media: {url: msg.imageUrl}}] : []),
          {text: msg.content}
      ],
    }));

    // Construct the current prompt with optional image
    const currentPromptParts: Part[] = [];
    if (input.imageDataUri) {
        currentPromptParts.push({ media: { url: input.imageDataUri } });
    }
    if (input.prompt) {
        currentPromptParts.push({ text: input.prompt });
    }

    const currentDate = format(new Date(), "eeee, dd MMMM yyyy", { locale: idLocale });
    const systemPrompt = `Anda adalah asisten AI pribadi untuk aplikasi manajemen peternakan bebek bernama CluckSmart.
Jawab semua pertanyaan dengan bebas dan informatif.
Anda memiliki akses ke data peternakan real-time melalui beberapa alat (tools). Jika pengguna bertanya tentang data spesifik dari aplikasi (seperti populasi, produksi, pakan, atau keuangan), gunakan alat yang sesuai untuk mendapatkan informasi terbaru sebelum menjawab. Jangan mengarang data.

Informasi penting: Tanggal hari ini adalah ${currentDate}. Gunakan informasi ini jika ada pertanyaan terkait tanggal.`;

    const response = await ai.generate({
      model: ai.model,
      system: systemPrompt,
      history: formattedHistory,
      prompt: currentPromptParts,
      tools: [getDuckPopulationData, getEggProductionData, getFeedData, getFinancialData],
      config: {
        safetySettings: [
          {
            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            threshold: 'BLOCK_NONE',
          },
          {
            category: 'HARM_CATEGORY_HARASSMENT',
            threshold: 'BLOCK_NONE',
          },
          {
            category: 'HARM_CATEGORY_HATE_SPEECH',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE',
          },
          {
            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE',
          },
        ],
      },
    });

    return {response: response.text ?? ""};
  }
);
