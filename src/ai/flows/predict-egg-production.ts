// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview A flow to predict egg production based on various factors.
 *
 * - predictEggProduction - Predicts egg production using AI.
 * - PredictEggProductionInput - The input type for predictEggProduction.
 * - PredictEggProductionOutput - The output type for predictEggProduction.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { format, eachDayOfInterval, differenceInDays, parse } from 'date-fns';
import { id as idLocale } from 'date-fns/locale';


const DuckInfoSchema = z.object({
  cage: z.number().describe('Nomor kandang'),
  quantity: z.number().describe('Jumlah bebek di kandang ini'),
  ageMonths: z.number().describe('Usia rata-rata bebek di kandang ini (bulan)'),
  cageSize: z.string().describe('Ukuran kandang (misal: 10m x 5m)'),
  cageSystem: z.string().describe('Sistem kandang (baterai atau umbaran)'),
});

const ProductionHistorySchema = z.object({
    date: z.string().describe('Tanggal produksi (YYYY-MM-DD)'),
    totalEggs: z.number().describe('Jumlah telur total pada tanggal tersebut'),
});

const FeedInfoSchema = z.object({
    name: z.string().describe('Nama pakan'),
    schema: z.number().describe('Skema pakan dalam gram per ekor per hari'),
});


const PredictEggProductionInputSchema = z.object({
  duckInfo: z.array(DuckInfoSchema).describe('Informasi detail dari setiap kandang bebek.'),
  productionHistory: z.array(ProductionHistorySchema).describe('Data historis produksi telur selama 30 hari terakhir.'),
  feedInfo: z.array(FeedInfoSchema).describe('Informasi mengenai pakan yang digunakan.'),
  housingInformation: z.string().describe('Informasi tambahan mengenai lingkungan atau kondisi umum kandang.'),
  startDate: z.string().describe('Tanggal mulai prediksi dalam format ISO (YYYY-MM-DD).'),
  endDate: z.string().describe('Tanggal akhir prediksi dalam format ISO (YYYY-MM-DD).'),
});
export type PredictEggProductionInput = z.infer<typeof PredictEggProductionInputSchema>;

const DailyPredictionSchema = z.object({
    day: z.string().describe("Tanggal yang diprediksi (misal: 25 Juli 2024)"),
    predictedEggs: z.number().describe('Jumlah telur yang diprediksi untuk tanggal tersebut.'),
});

const PredictEggProductionOutputSchema = z.object({
  dailyPredictions: z.array(DailyPredictionSchema).describe('Prediksi produksi telur untuk setiap hari dalam rentang yang diminta.'),
  reasoning: z.string().describe('Alasan AI di balik prediksi, mempertimbangkan tren dan semua data yang diberikan.'),
  totalPredictedProduction: z.number().describe('Jumlah total telur yang diprediksi selama seluruh periode.'),
});
export type PredictEggProductionOutput = z.infer<typeof PredictEggProductionOutputSchema>;

export async function predictEggProduction(input: PredictEggProductionInput): Promise<PredictEggProductionOutput> {
  return predictEggProductionFlow(input);
}

const predictEggProductionPrompt = ai.definePrompt({
  name: 'predictEggProductionPrompt',
  input: {schema: PredictEggProductionInputSchema},
  output: {schema: PredictEggProductionOutputSchema},
  prompt: `Anda adalah asisten manajemen peternakan AI yang sangat ahli dalam menganalisis data dan memprediksi produksi telur bebek.

  Berdasarkan data komprehensif yang diberikan, lakukan analisis mendalam untuk memprediksi jumlah total telur yang akan diproduksi untuk periode dari **{{startDate}}** hingga **{{endDate}}**. Pertimbangkan semua variabel yang ada:
  - Data dari setiap kandang (jumlah bebek, usia, sistem). Usia sangat berpengaruh pada produktivitas.
  - **Data historis produksi selama 30 hari terakhir**. Ini adalah indikator performa terkini yang paling penting untuk melihat tren.
  - Jenis pakan yang digunakan dan skemanya. Kualitas dan kuantitas pakan adalah faktor kunci.
  - Informasi tambahan mengenai lingkungan.

  **Tugas Anda:**
  1.  **Analisis Tren**: Analisis data historis produksi untuk mengidentifikasi tren (naik, turun, atau stabil). Gunakan tren ini sebagai dasar utama prediksi Anda.
  2.  **Prediksi Produksi**: Buat prediksi produksi telur untuk **SETIAP HARI** dalam rentang tanggal yang diminta, melanjutkan tren yang ada dan menyesuaikannya dengan faktor lain (usia bebek, pakan, dll). Format tanggal di output 'day' harus 'dd MMMM yyyy' dalam Bahasa Indonesia (contoh: 25 Juli 2024). Isi array 'dailyPredictions'.
  3.  **Total Prediksi**: Hitung total prediksi produksi selama periode tersebut dan isi field 'totalPredictedProduction'.
  4.  **Analisis & Rekomendasi Mendalam (Sertakan di 'reasoning')**:
      a.  **Alasan Prediksi Telur**: Berikan alasan yang detail dan logis untuk prediksi Anda. Jelaskan tren yang Anda identifikasi dari data historis dan bagaimana Anda menghubungkannya dengan variabel lain untuk sampai pada kesimpulan Anda.
      b.  **Analisis Pakan & Nutrisi**: Berikan analisis mendalam tentang penggunaan pakan saat ini. Jelaskan tentang pentingnya komposisi nutrisi (protein, energi, kalsium) untuk bebek petelur. Berikan informasi nutrisi spesifik untuk pakan seperti **Kebi**, **144 MHD**, dan bahan baku seperti **bungkil kedelai**, termasuk perkiraan kandungan protein kasarnya (misal: Kebi ~17%, 144 MHD ~18-20%, Bungkil Kedelai ~46%).
      c.  **Pakan Pabrikan**: Sebutkan beberapa contoh merek pakan pabrikan yang populer di Indonesia (misalnya: Charoen Pokphand, Japfa Comfeed, New Hope). Jelaskan kelebihan pakan pabrikan seperti konsistensi nutrisi dan kepraktisan.
      d.  **Pakan Mixing (Campuran Sendiri)**: Berikan informasi mendalam tentang pakan mixing. Jelaskan potensi keuntungan (biaya lebih rendah) dan kerugian (inkonsistensi nutrisi, butuh tenaga lebih). Berikan contoh resep dasar pakan mixing (misal: kombinasi dedak, jagung giling, konsentrat, dan mineral) dan tips untuk menjaga kualitasnya.
      e.  **Vitamin & Mineral**: Jelaskan pentingnya suplemen vitamin (seperti Vitachick atau Neobro) dan mineral untuk kesehatan, daya tahan tubuh, dan kualitas cangkang telur. Berikan rekomendasi penggunaannya.

  **CONTOH FORMAT JSON OUTPUT YANG DIHARAPKAN:**
  Pastikan nama field di dalam array 'dailyPredictions' adalah **'predictedEggs'**.
  \`\`\`json
  {
    "dailyPredictions": [
      { "day": "01 Januari 2025", "predictedEggs": 120 },
      { "day": "02 Januari 2025", "predictedEggs": 122 }
    ],
    "reasoning": "Berdasarkan data historis, terdapat tren kenaikan produksi rata-rata 2 butir per hari. Tren ini diproyeksikan akan terus berlanjut...\\n\\n**Analisis Pakan & Nutrisi:**\\nKomposisi nutrisi pakan saat ini adalah... Pakan Kebi memiliki protein kasar sekitar 17%...\\n\\n**Pakan Pabrikan:**\\n...\\n\\n**Pakan Mixing (Campuran Sendiri):**\\n...\\n\\n**Vitamin & Mineral:**\\n...",
    "totalPredictedProduction": 242
  }
  \`\`\`

  DATA POPULASI PER KANDANG:
  {{#each duckInfo}}
  - Kandang {{cage}}: {{quantity}} ekor, Usia {{ageMonths}} bulan, Ukuran {{cageSize}}, Sistem {{cageSystem}}
  {{/each}}
  
  DATA HISTORIS PRODUKSI (30 HARI TERAKHIR):
  {{#each productionHistory}}
  - {{date}}: {{totalEggs}} butir
  {{/each}}

  DATA PAKAN:
  {{#each feedInfo}}
  - {{name}}: {{schema}} gram/ekor/hari
  {{/each}}

  INFORMASI LINGKUNGAN TAMBAHAN:
  {{{housingInformation}}}
  
  PERIODE PREDIKSI: Dari {{startDate}} hingga {{endDate}}.
  
  Berikan respons dalam format JSON.`,
  model: 'googleai/gemini-2.0-flash',
});

const predictEggProductionFlow = ai.defineFlow(
  {
    name: 'predictEggProductionFlow',
    inputSchema: PredictEggProductionInputSchema,
    outputSchema: PredictEggProductionOutputSchema,
  },
  async (input) => {
    const {output} = await predictEggProductionPrompt(input);

    if (!output) {
      throw new Error('AI did not return a valid output.');
    }

    // Sort predictions by date just in case the AI doesn't return them in order
    const sortedPredictions = output.dailyPredictions.sort((a, b) => {
      try {
        const dateA = parse(a.day, 'dd MMMM yyyy', new Date(input.startDate), {
          locale: idLocale,
        });
        const dateB = parse(b.day, 'dd MMMM yyyy', new Date(input.startDate), {
          locale: idLocale,
        });
        if (isNaN(dateA.getTime()) || isNaN(dateB.getTime())) {
          return 0; // Don't sort if dates are invalid
        }
        return dateA.getTime() - dateB.getTime();
      } catch (e) {
        // Handle parsing error if the date format is wrong
        console.warn(`Could not parse date for sorting: ${a.day} or ${b.day}`);
        return 0;
      }
    });

    return {...output, dailyPredictions: sortedPredictions};
  }
);
